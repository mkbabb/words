#!/bin/bash

# Unified deployment script for Floridify
# Used by both local deployment and GitHub Actions

set -e

# Load configuration from .env.production if available
if [ -f ".env.production" ]; then
    # Source configuration from .env.production
    EC2_HOST_DEFAULT=$(grep '^EC2_HOST=' .env.production | cut -d'=' -f2-)
    EC2_USER_DEFAULT=$(grep '^EC2_USER=' .env.production | cut -d'=' -f2-)
    DOMAIN_DEFAULT=$(grep '^DOMAIN=' .env.production | cut -d'=' -f2-)
    REGISTRY_DEFAULT=$(grep '^REGISTRY=' .env.production | cut -d'=' -f2-)
    REPO_OWNER_DEFAULT=$(grep '^REPO_OWNER=' .env.production | cut -d'=' -f2-)
    VERSION_DEFAULT=$(grep '^VERSION=' .env.production | cut -d'=' -f2-)
else
    # Fallback defaults
    EC2_HOST_DEFAULT="54.209.241.47"
    EC2_USER_DEFAULT="ubuntu"
    DOMAIN_DEFAULT="words.babb.dev"
    REGISTRY_DEFAULT="ghcr.io"
    REPO_OWNER_DEFAULT="mkbabb"
    VERSION_DEFAULT="latest"
fi

# Configuration with defaults from .env.production or environment
export EC2_HOST="${EC2_HOST:-$EC2_HOST_DEFAULT}"
export EC2_USER="${EC2_USER:-$EC2_USER_DEFAULT}"
export DOMAIN="${DOMAIN:-$DOMAIN_DEFAULT}"
export REGISTRY="${REGISTRY:-$REGISTRY_DEFAULT}"
export REPO_OWNER="${REPO_OWNER:-$REPO_OWNER_DEFAULT}"
export VERSION="${VERSION:-$VERSION_DEFAULT}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

print_status() {
    echo -e "${GREEN}[$(date '+%Y-%m-%d %H:%M:%S')]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

# Check if running in GitHub Actions
is_github_actions() {
    [[ "${GITHUB_ACTIONS}" == "true" ]]
}

# Setup SSH key (different for local vs CI)
setup_ssh() {
    print_status "Setting up SSH access..."
    
    mkdir -p ~/.ssh
    
    if is_github_actions; then
        # GitHub Actions: SSH key from secret
        echo "$EC2_SSH_KEY" > ~/.ssh/deploy_key
        chmod 600 ~/.ssh/deploy_key
        SSH_KEY_PATH="~/.ssh/deploy_key"
    else
        # Local: use default SSH key
        SSH_KEY_PATH="~/.ssh/id_rsa"
        if [ ! -f "$HOME/.ssh/id_rsa" ]; then
            print_error "SSH private key not found at ~/.ssh/id_rsa"
            exit 1
        fi
    fi
    
    ssh-keyscan -H $EC2_HOST >> ~/.ssh/known_hosts 2>/dev/null || true
    export SSH_KEY_PATH
    print_status "âœ“ SSH configured"
}

# Test SSH connection
test_ssh() {
    print_status "Testing SSH connection to $EC2_HOST..."
    
    local ssh_opts="-o StrictHostKeyChecking=no -o ConnectTimeout=10"
    if is_github_actions; then
        ssh_opts="$ssh_opts -i ~/.ssh/deploy_key"
    fi
    
    if ssh $ssh_opts $EC2_USER@$EC2_HOST 'echo "SSH connection successful"' &>/dev/null; then
        print_status "âœ“ SSH connection verified"
    else
        print_error "Cannot connect to EC2 instance via SSH"
        exit 1
    fi
}

# Prepare EC2 server
prepare_ec2() {
    print_status "Preparing EC2 server..."
    
    local ssh_cmd="ssh -o StrictHostKeyChecking=no"
    if is_github_actions; then
        ssh_cmd="$ssh_cmd -i ~/.ssh/deploy_key"
    fi
    
    $ssh_cmd $EC2_USER@$EC2_HOST << 'EOSSH'
        # Update system
        sudo apt-get update
        
        # Install Docker if not present
        if ! command -v docker &> /dev/null; then
            echo "Installing Docker..."
            curl -fsSL https://get.docker.com | sudo sh
            sudo usermod -aG docker $USER
        fi
        
        # Install Docker Compose if not present
        if ! command -v docker-compose &> /dev/null; then
            echo "Installing Docker Compose..."
            sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
        fi
        
        # Create app directory
        mkdir -p ~/floridify/nginx/user_conf.d
        
        # Start Docker service
        sudo systemctl start docker
        sudo systemctl enable docker
        
        echo "EC2 server prepared successfully"
EOSSH

    print_status "âœ“ EC2 server prepared"
}

# Create production environment file
create_env_file() {
    print_status "Creating production environment file..."
    
    cat > .env.production << EOF
# Production Environment
DOMAIN=$DOMAIN
CERTBOT_EMAIL=${CERTBOT_EMAIL:-mike@babb.dev}
ENVIRONMENT=production
LOG_LEVEL=INFO
BUILD_TARGET=production
BACKEND_CORS_ORIGINS=["https://$DOMAIN","https://www.$DOMAIN"]
FRONTEND_PORT=80
VITE_API_URL=https://$DOMAIN/api
VITE_APP_TITLE=Floridify
REGISTRY=$REGISTRY
REPO_OWNER=$REPO_OWNER
VERSION=$VERSION
AWS_REGION=us-east-1
EC2_HOST=$EC2_HOST
EC2_USER=$EC2_USER
EOF

    print_status "âœ“ Environment file created"
}

# Copy deployment files to EC2
copy_files() {
    print_status "Copying deployment files to EC2..."
    
    local scp_opts="-o StrictHostKeyChecking=no"
    if is_github_actions; then
        scp_opts="$scp_opts -i ~/.ssh/deploy_key"
    fi
    
    # Copy Docker Compose files and environment
    scp $scp_opts \
        docker-compose.yml \
        docker-compose.prod.yml \
        .env.production \
        $EC2_USER@$EC2_HOST:~/floridify/
    
    # Copy nginx configuration
    scp $scp_opts \
        nginx/user_conf.d/floridify.conf \
        $EC2_USER@$EC2_HOST:~/floridify/nginx/user_conf.d/
    
    # Copy auth configuration
    scp $scp_opts -r \
        auth \
        $EC2_USER@$EC2_HOST:~/floridify/
    
    print_status "âœ“ Files copied to EC2"
}

# Deploy application on EC2
deploy_app() {
    print_status "Deploying application on EC2..."
    
    local ssh_cmd="ssh -o StrictHostKeyChecking=no"
    if is_github_actions; then
        ssh_cmd="$ssh_cmd -i ~/.ssh/deploy_key"
    fi
    
    $ssh_cmd $EC2_USER@$EC2_HOST << 'EOSSH'
        cd ~/floridify
        
        # Set environment variables from .env.production
        export $(cat .env.production | grep -v '^#' | xargs)
        
        # Login to GitHub Container Registry if token available
        if [ -n "$GITHUB_TOKEN" ]; then
            echo "Logging into GitHub Container Registry..."
            echo "$GITHUB_TOKEN" | docker login ghcr.io -u "$REPO_OWNER" --password-stdin
        fi
        
        # Pull latest images
        echo "Pulling latest Docker images..."
        docker-compose -f docker-compose.yml -f docker-compose.prod.yml pull || echo "Pull failed, will build locally"
        
        # Stop existing containers
        echo "Stopping existing containers..."
        docker-compose -f docker-compose.yml -f docker-compose.prod.yml --profile ssl down || true
        
        # Start new deployment with SSL
        echo "Starting services with SSL..."
        docker-compose -f docker-compose.yml -f docker-compose.prod.yml --profile ssl up -d --build
        
        # Wait for services to start
        sleep 30
        
        # Show status
        echo "=== Deployment Status ==="
        docker-compose -f docker-compose.yml -f docker-compose.prod.yml ps
        
        echo "=== Container Logs (last 20 lines) ==="
        docker-compose -f docker-compose.yml -f docker-compose.prod.yml logs --tail=20
        
        # Clean up old images
        docker image prune -f
        
        echo "Deployment completed successfully!"
EOSSH

    print_status "âœ“ Application deployed"
}

# Verify deployment
verify_deployment() {
    print_status "Verifying deployment..."
    
    print_info "Waiting for services to be ready..."
    sleep 60
    
    # Check if the application responds
    print_info "Testing application endpoint..."
    response=$(curl -s -o /dev/null -w "%{http_code}" -L https://$DOMAIN/api/health || echo "000")
    
    if [ "$response" = "200" ]; then
        print_status "âœ… Application is healthy at https://$DOMAIN"
    elif [ "$response" = "000" ]; then
        print_warning "âš ï¸  Application is not responding yet. SSL certificate may still be provisioning."
        print_info "Check manually: https://$DOMAIN"
    else
        print_warning "âŒ Application responded with HTTP $response"
        print_info "Check deployment logs on EC2"
    fi
}

# Cleanup temporary files
cleanup() {
    if is_github_actions; then
        rm -f ~/.ssh/deploy_key .env.production 2>/dev/null || true
    else
        rm -f .env.production 2>/dev/null || true
    fi
}

# Main deployment function
main() {
    print_status "ðŸš€ Starting Floridify deployment to $EC2_HOST"
    
    # MongoDB configuration is now handled via auth/config.toml
    
    # Trap cleanup on exit
    trap cleanup EXIT
    
    setup_ssh
    test_ssh
    prepare_ec2
    create_env_file
    copy_files
    deploy_app
    verify_deployment
    
    print_status "ðŸŽ‰ Deployment completed successfully!"
    print_info "ðŸ“± Frontend: https://$DOMAIN"
    print_info "ðŸ”§ API: https://$DOMAIN/api"
    print_info "ðŸ“š API Docs: https://$DOMAIN/api/docs"
}

# Help message
if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
    echo "Floridify Deployment Script"
    echo ""
    echo "This unified script handles deployment to EC2 for both:"
    echo "  - Local deployment (uses ~/.ssh/id_rsa)"
    echo "  - GitHub Actions CI/CD (uses EC2_SSH_KEY secret)"
    echo ""
    echo "Environment Variables:"
    # MongoDB configuration is in auth/config.toml (copied to server)
    echo "  EC2_HOST        - Optional: EC2 IP (default: 54.209.241.47)"
    echo "  EC2_USER        - Optional: EC2 username (default: ubuntu)"
    echo "  DOMAIN          - Optional: Domain name (default: words.babb.dev)"
    echo "  CERTBOT_EMAIL   - Optional: Email for Let's Encrypt"
    echo "  GITHUB_TOKEN    - Optional: For container registry access"
    echo ""
    echo "Usage:"
    echo "  Local:        ./deploy.sh  (uses auth/config.toml)"
    echo "  GitHub Actions: Automatically uses secrets"
    exit 0
fi

main "$@"