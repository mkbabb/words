#!/bin/bash

# Direct server-side deployment script for Floridify
# Builds containers directly on server - no GitHub registry needed

set -e

# Load configuration from .env.production or .env if available
if [ -f ".env.production" ]; then
    # Source configuration from .env.production
    EC2_HOST_DEFAULT=$(grep '^EC2_HOST=' .env.production | cut -d'=' -f2-)
    EC2_USER_DEFAULT=$(grep '^EC2_USER=' .env.production | cut -d'=' -f2-)
    DOMAIN_DEFAULT=$(grep '^DOMAIN=' .env.production | cut -d'=' -f2-)
elif [ -f ".env" ]; then
    # Source configuration from .env
    EC2_HOST_DEFAULT=$(grep '^EC2_HOST=' .env | cut -d'=' -f2-)
    EC2_USER_DEFAULT=$(grep '^EC2_USER=' .env | cut -d'=' -f2-)
    DOMAIN_DEFAULT=$(grep '^DOMAIN=' .env | cut -d'=' -f2-)
else
    # Fallback defaults
    EC2_HOST_DEFAULT="44.216.140.209"
    EC2_USER_DEFAULT="ubuntu"
    DOMAIN_DEFAULT="words.babb.dev"
fi

# Configuration with defaults from .env.production or environment
export EC2_HOST="${EC2_HOST:-$EC2_HOST_DEFAULT}"
export EC2_USER="${EC2_USER:-$EC2_USER_DEFAULT}"
export DOMAIN="${DOMAIN:-$DOMAIN_DEFAULT}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

print_status() {
    echo -e "${GREEN}[$(date '+%Y-%m-%d %H:%M:%S')]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

# Check if running in GitHub Actions
is_github_actions() {
    [[ "${GITHUB_ACTIONS}" == "true" ]]
}

# Setup SSH key (different for local vs CI)
setup_ssh() {
    print_status "Setting up SSH access..."
    
    mkdir -p ~/.ssh
    
    if is_github_actions; then
        # GitHub Actions: SSH key from secret
        echo "$EC2_SSH_KEY" > ~/.ssh/deploy_key
        chmod 600 ~/.ssh/deploy_key
        SSH_KEY_PATH="~/.ssh/deploy_key"
    else
        # Local: use default SSH key
        SSH_KEY_PATH="~/.ssh/id_rsa"
        if [ ! -f "$HOME/.ssh/id_rsa" ]; then
            print_error "SSH private key not found at ~/.ssh/id_rsa"
            exit 1
        fi
    fi
    
    ssh-keyscan -H $EC2_HOST >> ~/.ssh/known_hosts 2>/dev/null || true
    export SSH_KEY_PATH
    print_status "âœ“ SSH configured"
}

# Test SSH connection
test_ssh() {
    print_status "Testing SSH connection to $EC2_HOST..."
    
    local ssh_opts="-o StrictHostKeyChecking=no -o ConnectTimeout=10"
    if is_github_actions; then
        ssh_opts="$ssh_opts -i ~/.ssh/deploy_key"
        # Debug: Check if key file exists and has correct permissions
        if [ ! -f ~/.ssh/deploy_key ]; then
            print_error "SSH key file not found at ~/.ssh/deploy_key"
            exit 1
        fi
        print_info "SSH key file exists with permissions: $(ls -l ~/.ssh/deploy_key | awk '{print $1}')"
    fi
    
    # Try SSH with verbose output for debugging
    if is_github_actions; then
        print_info "Attempting SSH connection with verbose output..."
        ssh -v $ssh_opts $EC2_USER@$EC2_HOST 'echo "SSH connection successful"' 2>&1 | tail -20
    fi
    
    if ssh $ssh_opts $EC2_USER@$EC2_HOST 'echo "SSH connection successful"' &>/dev/null; then
        print_status "âœ“ SSH connection verified"
    else
        print_error "Cannot connect to EC2 instance via SSH"
        print_info "Please check:"
        print_info "  - EC2_HOST is correct: $EC2_HOST"
        print_info "  - EC2_USER is correct: $EC2_USER"
        print_info "  - SSH key is properly formatted in GitHub secrets"
        print_info "  - EC2 security group allows SSH from GitHub Actions IPs"
        exit 1
    fi
}

# Simple deployment - SSH to server and run Docker commands directly
deploy_on_server() {
    print_status "Deploying on server..."
    
    local ssh_cmd="ssh -o StrictHostKeyChecking=no"
    if is_github_actions; then
        ssh_cmd="$ssh_cmd -i ~/.ssh/deploy_key"
    fi
    
    $ssh_cmd $EC2_USER@$EC2_HOST << ENDSSH
        set -e  # Exit on error
        
        # Check if floridify directory exists, if not clone it
        if [ ! -d ~/floridify ]; then
            echo "Cloning repository..."
            git clone https://github.com/mkbabb/words.git ~/floridify
        fi
        
        cd ~/floridify
        
        # Pull latest code
        echo "Pulling latest code..."
        git pull origin master
        
        # Make sure auth directory exists and has config
        if [ ! -f ~/floridify/auth/config.toml ]; then
            echo "Error: auth/config.toml not found on server"
            echo "Please ensure auth/config.toml exists at ~/floridify/auth/config.toml"
            exit 1
        fi
        
        # Create .env file with actual domain
        cat > .env << ENV_EOF
# Production Environment
DOMAIN=$DOMAIN
CERTBOT_EMAIL=${CERTBOT_EMAIL:-mike@babb.dev}
ENVIRONMENT=production
LOG_LEVEL=INFO
BUILD_TARGET=production
BACKEND_CORS_ORIGINS=["https://$DOMAIN","https://www.$DOMAIN"]
FRONTEND_PORT=3001
VITE_API_URL=https://$DOMAIN/api
VITE_APP_TITLE=Floridify
AWS_REGION=us-east-1
ENV_EOF
        
        # Run the setup script if available
        if [ -f ./scripts/setup ]; then
            echo "Running setup script..."
            chmod +x ./scripts/setup
            ./scripts/setup
        fi
        
        # Build and deploy with Docker Compose
        echo "Building and deploying with Docker Compose..."
        docker compose -f docker-compose.yml -f docker-compose.prod.yml build
        docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d
        
        # Show container status
        echo ""
        echo "Container status:"
        docker compose ps
        
        echo ""
        echo "Deployment completed on server!"
ENDSSH
    
    print_status "âœ“ Deployment completed"
}

# Create production environment file on server
create_env_file() {
    print_status "Creating production environment file..."
    
    local ssh_cmd="ssh -o StrictHostKeyChecking=no"
    if is_github_actions; then
        ssh_cmd="$ssh_cmd -i ~/.ssh/deploy_key"
    fi
    
    $ssh_cmd $EC2_USER@$EC2_HOST << EOF
        cd ~/floridify
        cat > .env << 'ENV_EOF'
# Production Environment
DOMAIN=$DOMAIN
CERTBOT_EMAIL=${CERTBOT_EMAIL:-mike@babb.dev}
ENVIRONMENT=production
LOG_LEVEL=INFO
BUILD_TARGET=production
BACKEND_CORS_ORIGINS=["https://$DOMAIN","https://www.$DOMAIN"]
FRONTEND_PORT=3001
VITE_API_URL=https://$DOMAIN/api
VITE_APP_TITLE=Floridify
AWS_REGION=us-east-1
EC2_HOST=$EC2_HOST
EC2_USER=$EC2_USER
ENV_EOF
        echo "Environment file created successfully"
EOF

    print_status "âœ“ Environment file created"
}

# Copy auth configuration from local to server
copy_auth_config() {
    print_status "Copying auth configuration to server..."
    
    # Check if local auth/config.toml exists
    if [ ! -f "auth/config.toml" ]; then
        print_error "auth/config.toml not found locally"
        print_info "Run ./scripts/setup first to configure auth"
        exit 1
    fi
    
    local ssh_cmd="ssh -o StrictHostKeyChecking=no"
    if is_github_actions; then
        ssh_cmd="$ssh_cmd -i ~/.ssh/deploy_key"
    fi
    
    # Create auth directory on server
    $ssh_cmd $EC2_USER@$EC2_HOST 'mkdir -p ~/floridify/auth'
    
    # Copy config file
    if is_github_actions; then
        scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no auth/config.toml $EC2_USER@$EC2_HOST:~/floridify/auth/
    else
        scp -o StrictHostKeyChecking=no auth/config.toml $EC2_USER@$EC2_HOST:~/floridify/auth/
    fi
    
    print_status "âœ“ Auth configuration copied"
}

# Build and deploy application on server
build_and_deploy() {
    print_status "Building and deploying application..."
    
    local ssh_cmd="ssh -o StrictHostKeyChecking=no"
    if is_github_actions; then
        ssh_cmd="$ssh_cmd -i ~/.ssh/deploy_key"
    fi
    
    $ssh_cmd $EC2_USER@$EC2_HOST << 'EOSSH'
        cd ~/floridify
        
        # Install Docker and Docker Compose if not present
        if ! command -v docker &> /dev/null; then
            echo "Installing Docker..."
            curl -fsSL https://get.docker.com | sudo sh
            sudo usermod -aG docker $USER
            sudo systemctl start docker
            sudo systemctl enable docker
        fi
        
        if ! command -v docker-compose &> /dev/null; then
            echo "Installing Docker Compose..."
            sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
        fi
        
        # Stop existing containers
        echo "Stopping existing containers..."
        sudo docker-compose -f docker-compose.yml -f docker-compose.prod.yml --profile ssl down || true
        
        # Build containers directly on server
        echo "Building containers on server..."
        sudo docker-compose -f docker-compose.yml -f docker-compose.prod.yml build --no-cache
        
        # Start new deployment with SSL
        echo "Starting services with SSL..."
        sudo docker-compose -f docker-compose.yml -f docker-compose.prod.yml --profile ssl up -d
        
        # Wait for services to start
        sleep 30
        
        # Show status
        echo "=== Deployment Status ==="
        sudo docker-compose -f docker-compose.yml -f docker-compose.prod.yml ps
        
        # Clean up old images and build cache
        sudo docker image prune -f
        sudo docker builder prune -f
        
        echo "Build and deployment completed successfully!"
EOSSH

    print_status "âœ“ Application built and deployed"
}

# Verify deployment
verify_deployment() {
    print_status "Verifying deployment..."
    
    print_info "Waiting for services to be ready..."
    sleep 60
    
    # Check if the application responds
    print_info "Testing application endpoint..."
    response=$(curl -s -o /dev/null -w "%{http_code}" -L https://$DOMAIN/api/health || echo "000")
    
    if [ "$response" = "200" ]; then
        print_status "âœ… Application is healthy at https://$DOMAIN"
    elif [ "$response" = "000" ]; then
        print_warning "âš ï¸  Application is not responding yet. SSL certificate may still be provisioning."
        print_info "Check manually: https://$DOMAIN"
    else
        print_warning "âŒ Application responded with HTTP $response"
        print_info "Check deployment logs on server"
    fi
}

# Cleanup temporary files
cleanup() {
    if is_github_actions; then
        rm -f ~/.ssh/deploy_key 2>/dev/null || true
    fi
}

# Main deployment function
main() {
    print_status "ðŸš€ Starting Floridify deployment to $EC2_HOST"
    
    # Setup and test SSH connection
    setup_ssh
    test_ssh
    
    # Deploy on server
    deploy_on_server
    
    # Verify deployment
    verify_deployment
    
    print_status "ðŸŽ‰ Deployment completed successfully!"
    print_info "ðŸ“± Frontend: https://$DOMAIN"
    print_info "ðŸ”§ API: https://$DOMAIN/api"
    print_info "ðŸ“š API Docs: https://$DOMAIN/api/docs"
}

# Help message
if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
    echo "Floridify Deployment Script"
    echo ""
    echo "Deploys to EC2 by:"
    echo "  1. SSHing to the server"
    echo "  2. Pulling latest code from GitHub"
    echo "  3. Building and running Docker containers"
    echo ""
    echo "Prerequisites:"
    echo "  - SSH access to EC2 instance"
    echo "  - auth/config.toml must exist on server at ~/floridify/auth/config.toml"
    echo "  - Docker and Docker Compose installed on server"
    echo ""
    echo "Environment Variables:"
    echo "  EC2_HOST       - EC2 IP address (default: 44.216.140.209)"
    echo "  EC2_USER       - EC2 username (default: ubuntu)"
    echo "  DOMAIN         - Domain name (default: words.babb.dev)"
    echo "  CERTBOT_EMAIL  - Email for SSL certificates (default: mike@babb.dev)"
    echo ""
    echo "Usage:"
    echo "  ./scripts/deploy"
    exit 0
fi

main "$@"